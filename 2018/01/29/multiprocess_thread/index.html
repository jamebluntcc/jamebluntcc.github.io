<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      python 线程与进程 | ChenCheng&#39;s Blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="ChenCheng">
    
    

    <meta name="description" content="多进程与多线程是一个在编程上经常涉及到的内容，在 python 中也有多线程与多进程。首先还是理解下什么是多进程与多线程吧，现在主流的操作系统都支持多任务，现在我们可以简单的理解为多任务都是多进程，当我们开启一个任务，比如打开一个 word 那就是开启了一个进程。打开 word 后我们可以在 word 上不只做一件事情，比如我们会编辑内容，打印等等，在一个进程的内部也会同时做很多的事情，需要同时执">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="python 线程与进程 | ChenCheng&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/2018/01/29/multiprocess_thread/index.html">
<meta property="og:site_name" content="ChenCheng&#39;s Blog">
<meta property="og:description" content="多进程与多线程是一个在编程上经常涉及到的内容，在 python 中也有多线程与多进程。首先还是理解下什么是多进程与多线程吧，现在主流的操作系统都支持多任务，现在我们可以简单的理解为多任务都是多进程，当我们开启一个任务，比如打开一个 word 那就是开启了一个进程。打开 word 后我们可以在 word 上不只做一件事情，比如我们会编辑内容，打印等等，在一个进程的内部也会同时做很多的事情，需要同时执">
<meta property="og:updated_time" content="2018-01-29T09:47:24.828Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python 线程与进程 | ChenCheng&#39;s Blog">
<meta name="twitter:description" content="多进程与多线程是一个在编程上经常涉及到的内容，在 python 中也有多线程与多进程。首先还是理解下什么是多进程与多线程吧，现在主流的操作系统都支持多任务，现在我们可以简单的理解为多任务都是多进程，当我们开启一个任务，比如打开一个 word 那就是开启了一个进程。打开 word 后我们可以在 word 上不只做一件事情，比如我们会编辑内容，打印等等，在一个进程的内部也会同时做很多的事情，需要同时执">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">ChenCheng&#39;s Blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          Teachnology only for better life
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/jamebluntcc" title="Huno on GitHub">
          <i class='icon icon-social-github'></i>
          <span class="label">GitHub</span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--
    
      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">python 线程与进程</h1>

    

    <div class="post-meta">
      <time datetime="2018-01-29" class="post-meta__date date">2018-01-29</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/program/">program</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/python/">python</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p>多进程与多线程是一个在编程上经常涉及到的内容，在 python 中也有多线程与多进程。首先还是理解下什么是多进程与多线程吧，现在主流的操作系统都支持多任务，现在我们可以简单的理解为多任务都是多进程，当我们开启一个任务，比如打开一个 word 那就是开启了一个进程。打开 word 后我们可以在 word 上不只做一件事情，比如我们会编辑内容，打印等等，在一个进程的内部也会同时做很多的事情，需要同时执行多个子任务，我们就把进程内的子任务叫做线程（thread）。<br>正常情况下我们编写的 python 程序都是单任务的进程，就是说只有一个线程。当我们涉及到同时执行多个子任务的时候，一般会有以下两种方法解决：</p>
<ul>
<li>启动多个进程，每一个进程只有一个线程，但是多进程可以一起执行任务。</li>
<li>启动一个进程，一个进程中会有多个线程，实现多线程执行多任务。</li>
</ul>
<p>往往多进程与多线程程序复杂度要远远高于单进程单线程的程序，因为多进程多线程会涉及到数据共享，同步等问题。</p>
<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>python 提供 multiprocessing 模块实现多进程编程，其中用 <code>Process</code> 类来代表一个进程对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Run child process &#123;&#125; (&#123;&#125;)'</span>.format(name, os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Parent process &#123;&#125;.'</span>.format(os.getpid())</span><br><span class="line">	p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Process will Start.'</span></span><br><span class="line">	p.start()</span><br><span class="line">	p.join()</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Process end.'</span></span><br></pre></td></tr></table></figure>
<p>创建子进程，只需要对 <code>Process</code> 对象传入函数对象与相应的参数，然后使用 <code>start()</code> 方法启动。<code>join()</code> 方法可以等待子进程结束后在继续往下运行，通常用于进程间的同步。</p>
<p>如果我们需要启动大量的子进程，可以使用进程池的方式创建大量的子进程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Run task &#123;&#125; (&#123;&#125;)...'</span>.format(name, os.getpid())</span><br><span class="line">	start = time.time()</span><br><span class="line">	time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">	end = time.time()</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Parent Process %s'</span> %(os.getpid())</span><br><span class="line">	p = Pool()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">		p.apply_async(long_time_task, args=(i,))</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Waiting for all subprocess done...'</span></span><br><span class="line">	p.close()</span><br><span class="line">	p.join()</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'All subprocess done.'</span></span><br></pre></td></tr></table></figure>
<p>对 <code>Pool</code> 对象调用 <code>join()</code> 方法会等待所有的子进程执行完毕，调用 <code>join()</code> 之前必须先调用 <code>close()</code> ，调用后就不能再添加新的 <code>Process</code> 。其中 <code>Pool()</code> 可以接受一个参数，这个参数默认是本机的 CPU 核数。如果是 4 核电脑那 <code>Pool</code> 的默认参数是 4。当然也可以自己改为 <code>Pool(5)</code> 这样就可以同时跑 5 个进程。</p>
<p>最后是关于进程间的通信，<code>Process</code> 之间肯定是需要通信的，在 <code>multiprocess</code> 中主要提供了 <code>Queue</code>，<code>Pipes</code> 进行数据交换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocess <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wirte</span><span class="params">(q)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'Put %s to queue...'</span> %value</span><br><span class="line">		q.put(value)</span><br><span class="line">		time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">	<span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">		value = q.get(<span class="keyword">True</span>)</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'Get %s from queue.'</span> %value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	q = Queue()</span><br><span class="line">	pw = Process(target=write, args=(q,))</span><br><span class="line">	pr = Process(target=read, args=(q,))</span><br><span class="line">	pw.start() <span class="comment"># 启动 pw 写入</span></span><br><span class="line">	pr.start() <span class="comment"># 启动 pr 读取</span></span><br><span class="line">	pw.join() <span class="comment"># 等待 pw 结束</span></span><br><span class="line">	pr.terminate() <span class="comment"># pr 是一个死循环 无法等待结束，只能强行终止</span></span><br></pre></td></tr></table></figure>
<p>如上代码所示，通过 <code>multiprocess</code> 的 <code>Queue</code> 和 <code>Pipes</code> 实现了进程间的数据互通。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多任务可以由多进程完成，当然也可以由一个进程内的多线程完成。线程是操作系统直接支持的执行单元。python 提供了两个模块来处理线程，一个叫 <code>thread</code> 一个叫 <code>threading</code> 其中 <code>thread</code> 更加偏向于底层，我们一般在使用的时候直接使用 <code>threading</code> 模块就可以了。启动一个线程就是将一个函数传入到 <code>threading</code> 所创建的实例中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'thread %s is running...'</span> % threading.current_thread().name</span><br><span class="line">	n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">		n += <span class="number">1</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'thread %s &gt;&gt;&gt; %s'</span> %(threading.current_thread().name, n)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'thread %s ended'</span> % threading.current_thread().name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	t = threading.thread(target=loop, name=<span class="string">'LoopThread'</span>)</span><br><span class="line">	s.start()</span><br><span class="line">	s.join()</span><br></pre></td></tr></table></figure>
<p>由于任何进程默认都会启动一个线程，我们将该线程称为主线程，主线程又可以启动新的线程， python 的 <code>threading</code> 模块有个 <code>current_thread()</code> 的函数，它返回当前线程的实例，主线程的名字叫做 <code>MainThread</code> 子线程的名字在创建时指定，我们使用 <code>LoopThread</code> 命名子线程。如果我们命名那 python 就会默认给线程命名为 <code>Thread-1</code>，<code>Thread-2</code>…</p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>多线程与多进程最大的差别在于，多进程中，同一个变量，各有一份拷贝在各自的进程中，互不影响。但是在线程中情况大不一样，所有的变量都可以被共享。任何一个变量都可以被其它线程修改，因此，线程之间的共享数据的最大危险在于多个线程改变一个变量，将内容改乱了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> balance</span><br><span class="line">	balance = blance + n</span><br><span class="line">	balance = blance - n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">		change_it(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"><span class="keyword">print</span> balance</span><br></pre></td></tr></table></figure>
<p>在上面定义了一个共享变量 <code>balance</code> 初始值为 <code>0</code>，并且启动了两个线程，理论上最后的值会是 <code>0</code> , 但是这里就不一定个了。因为线程的调度由操作系统决定，当 t1 和 t2 交替执行时，可能会改变最后的值。<br>所以要保证数据的正确性，就需要对线程进行修改数据的时候上锁，当线程开始执行的时候，会上一把锁，其它线程同时执行到的时候，会等待，直到锁被释放掉。由于锁只有一个，无论多个线程同一个时刻只有一个线程会有锁，所以不会造成修改的冲突。在 python 中通过 <code>threading.Lock()</code> 实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">		lock.acquire()</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			change_it(n)</span><br><span class="line">		<span class="keyword">finally</span>:</span><br><span class="line">			lock.release()</span><br></pre></td></tr></table></figure>
<p>上面通过 <code>lock.acquire()</code> 使得线程获得锁，最后一定要释放锁，否则会造成死线程。所以推荐使用 <code>try...finally</code> 来保证一定会被释放。</p>
<p>当然锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，当然，坏处就是组织了多线程的并发执行，包含锁的代码只能以单线程模式进行，效率就大大下降。其次由于可以不同的线程存在不同的锁，可能会导致死锁。</p>
<p>最后 python 的线程虽然是真正的线程，但是解释器在执行代码的时候，会有一个 <code>GIL</code> 锁：Global Interpreter Lock 任何 python 线程执行前，必须先获得 <code>GIL</code> 锁，然后每执行100条字节码，解释器就会自动释放 <code>GIL</code> 锁，让别的线程有机会执行 。这个<code>GIL</code> 锁实际上将全部的线程执行代码都上了锁，所以多线程在 python 上只能交替执行。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>在多线程环境下，每一个线程都有自己的数据，一个线程使用自己的局部变量总比使用全局变量好，因为局部变量只有自己可见，不会影响到其它线程。而全局变量又要上锁。但是局部变量也有自己的问题，在函数进行调用的时候，传递很麻烦：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">(name)</span>:</span></span><br><span class="line">	std = Student(name)</span><br><span class="line"></span><br><span class="line">	do_task_1(std)</span><br><span class="line">	do_task_2(std)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_1</span><span class="params">(std)</span>:</span></span><br><span class="line">	do_some1(std)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_2</span><span class="params">(std)</span>:</span></span><br><span class="line">	do_some2(std)</span><br></pre></td></tr></table></figure>
<p>可见每一个函数调用就会传递一次参数，使用全局变量不行，每一个线程处理不同的 std 对象。如果用一个全局 <code>dict</code> 来存放所有的 <code>Student</code> 对象，然后使用各个线程的实例作为 <code>key</code> 获取 std 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">global_dict = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">std_thread</span><span class="params">(name)</span>:</span></span><br><span class="line">	std = Student(name)</span><br><span class="line">	global_dict[threading.current_thread()] = std</span><br><span class="line">	do_task_1()</span><br><span class="line">	do_task_2()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_1</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># 不再传入 std 根据当前的线程来查询</span></span><br><span class="line">	std = global_dict[threading.current_thread()]</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这种方式理论可行，但是 <code>threading</code> 模块以及提供了更加合理简单的方式，<code>ThreadLocal</code> 应运而生，不需要查找 <code>dict</code>， <code>ThreadLocal</code> 帮我们自动做了这些事情：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">process_std</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Hello, %s (in %s)'</span> %(local_school.student, threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(name)</span>:</span></span><br><span class="line">	local_school.student = name</span><br><span class="line">	process_stduent()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	t1 = threading.Thread(target=process_thread, args=(<span class="string">'Alice'</span>,),name=<span class="string">'Thread-A'</span>)</span><br><span class="line">	t2 = threading.Thread(target=process_thread, args=(<span class="string">'Bob'</span>,),name=<span class="string">'Thread-B'</span>)</span><br><span class="line">	t1.start()</span><br><span class="line">	t2.start()</span><br><span class="line">	t1.join()</span><br><span class="line">	t2.join()</span><br></pre></td></tr></table></figure>
<p>全局变量 <code>local_school</code> 就是一个 <code>ThreadLocal</code> 对象，每一个 <code>Thread</code> 对它都可以读取 <code>student</code> 属性，但互不影响。可以理解全局变量 <code>local_school</code> 是一个 <code>dict</code>，不但可以使用 <code>local_school</code> 还可以绑定其它的值。它的每一个属性对于不同的线程都是属于线程自己的局部变量，互不干扰。</p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2016-2018. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>

        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
